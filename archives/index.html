<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge"><meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="format-detection" content="email=no"><meta name="description"><meta name="keywords" content="Hexo, Gruntjs, Nodejs, Reactjs, Vuejs,zzjemery"><title>占志杰的博客</title><link rel="stylesheet" href="/css/main_style.min.css"><link rel="icon" href="/favicon.ico"></head><body><input id="navi" type="checkbox"><ul class="main-navication"><li><a href="/"><span>Home</span></a></li><li><a href="https://github.com"><span>Github</span></a></li><li><a href="https://www.baidu.com/"><span>BaiDu</span></a></li></ul><div class="wrapper" id="wrap"><div class="page-header"><label class="navi-button" for="navi">MENU</label><div class="background"><img src="http://callfiles.ueibo.com/hexo-theme-laughing/page_background.jpg"></div><div class="author"><div class="head"><img src="http://oydnc50wi.bkt.clouddn.com/vae.png"></div><h3 class="name">zzjemery</h3><p class="signature">Only when you plant the flowers can you really smell their fragrance.</p></div></div><ul class="post-list" style="max-width:800px"><li> <p class="date">October 26, 2017</p><div class="no-title"><h1 id="JavaScript-面向对象"><a href="#JavaScript-面向对象" class="headerlink" title="JavaScript 面向对象"></a>JavaScript 面向对象</h1><ol>
<li>什么是对象？<br>面向对象编程(Object Oriented programming,缩写为OOP)是目前主流的编程范式。他将真实世界中各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作来完成对真实世界的虚拟。</li>
</ol>
<p>每一个对象都是功能中心，具有明确的分工，可以完成接受信息，发送信息，处理数据等任务。因此，面向对象编程具有灵活、代码可复用、高度模块化等特点，容易维护和开发，比起由一系列函数或指令组成的传统过程式编程(procedural programing),更适合多人合作的大型项目。</p>
<p>那么，对象(Object)到底是什么？</p>
<ul>
<li>①对象是单个事物的抽象<br>  一本书，一个人，一辆车都可以是对象。一个数据库，一张网页，一个服务器，甚至于与服务器的连接也可以是对象。当实物被抽象为对象，实物之间的关系就变成了对象之间的关系，从而就可以模拟现实情况，针对对象进行编程。</li>
<li>②对象是一个容器，封装了属性(property)和方法(method)。<br>  属性是对象的状态，而方法是对象的行为(完成某种任务)。比如，我们可以把动物抽象为animal对象，使用属性记录具体是哪种动物，使用方法来表示动物的某种行为(奔跑、捕猎、休息等等)</li>
</ul>
<ol>
<li><p>构造函数<br> 面向对象的第一步就是要生成对象。</p>
<p> 前面说过，对象即是单个实物的抽象，通常需要模板，表示某一类实物的共同特征，然后对象根据这个模板生成。<br> 经典的面向对象语言(c++,java等)存在“类”(Class)这个概念。所谓“类”就是对象的模板。它提供模板，描述对象的基本结构，一个构造函数，可以生成多个对象，这些对象具有相同的结构。</p>
<p> 构造函数的写法就是一个普通函数，但是有自己的特征和用法</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Vehicel =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.price = <span class="number">100</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p> 上面代码中，Vehicel就是一个构造函数，它提供模板，生成一个实例对象，为了与普通函数区别，构造函数名字的第一个字母通常大写。</p>
<blockquote>
<p>特征：函数体内部使用this关键字，代表所要生成的对象实例。<br>用法：生成对象的时候必须用new命名，调用Vehicel函数。</p>
</blockquote>
<ol>
<li><p>new 命令<br>3.1 基本用法<br>new 命令的作用，就是用来执行构造函数，返回一个实例对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Vehicel =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.price = <span class="number">100</span>;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> v =<span class="keyword">new</span> Vehicel();</div><div class="line">v.price;<span class="comment">//100</span></div></pre></td></tr></table></figure>
<p>上面代码通过new命令，通过构造函数Vehicel生成一个实例对象，保存在v中，这个新生成的实例对象，从构造函数中继承了Vehicel中继承了price属性，new命令执行时，构造函数内部的this，就代表了新生成的实例对象，this.price表示实例对象有一个price属性，值是100</p>
<p>使用new命令时，根据需要构造函数也可以接受参数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Vehicel =<span class="function"><span class="keyword">function</span>(<span class="params">p</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.price = <span class="number">100</span>;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> v = Vehicel(<span class="number">300</span>);</div></pre></td></tr></table></figure>
<p>new命令本身就可以执行构造函数，所以后面的构造函数可以带括号，也可以不带括号。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> v= <span class="keyword">new</span> Vehicel();</div><div class="line"><span class="keyword">var</span> v = <span class="keyword">new</span> Vehicel;</div></pre></td></tr></table></figure>
<p>以上两行代码是等价的。</p>
<p>一个问题：如果你忘记使用new命令，直接调用构造函数会发生什么？<br>这种情况下构造函数就变成了普通函数，并不会生成实例对象。而且由于后面会说的原因，this这时代表全局对象，将造成一些意想不到的结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Vehicel =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.price = <span class="number">100</span>;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> v =Vehicel();</div><div class="line">v.price;<span class="comment">//报错， price not defined</span></div><div class="line">price <span class="comment">//100</span></div></pre></td></tr></table></figure>
<p>上面的代码中，调用Vehicel构造函数忘了加上new命令，结果，price属性变成了全局变量，而变量v的值变成了undefined。</p>
<p>因此应该非常小心，避免出现不使用new命令，直接调用构造函数的情况。为了保证构造函数必须和new命令一起使用，一个解决办法是，在构造函数的内部使用严格模式，也就是在第一行加上 “use strict”。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fubar</span>(<span class="params">foo,bar</span>)</span>&#123;</div><div class="line"><span class="meta">    'use strict'</span>;</div><div class="line">    <span class="keyword">this</span>._foo=foo;</div><div class="line">    <span class="keyword">this</span>._bar=bar;</div><div class="line">&#125;</div><div class="line">Fubar();</div></pre></td></tr></table></figure>
<p>上面代码Fubar为构造函数，use strict命令保证了该函数在严格模式下运行，由于在严格模式中函数内部的this不能只想全局对象，默认为undefined，导致不加new调用时会报错。(严格模式下JavaScript不允许对undefined添加属性)</p>
<p>另外一个解决办法，是在构造函数内部判断是否使用new命令，如果发现没有new，则返回一个实例对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fubar</span>(<span class="params">foo,bar</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Fubar))&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Fubar(foo,bar);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>._foo=foo;</div><div class="line">    <span class="keyword">this</span>._bar=bar;</div><div class="line">&#125;</div><div class="line">Fubar(<span class="number">1</span>,<span class="number">2</span>)._foo ;<span class="comment">//1</span></div><div class="line">(<span class="keyword">new</span> Fubar(<span class="number">1</span>,<span class="number">2</span>))._foo;  <span class="comment">//1</span></div></pre></td></tr></table></figure>
<p>在上面代码中的构造函数，不管加不加new命令，都可以获得一个新的对象。</p>
<p>3.2 new命令的原理<br>使用new命令时，他后面的函数调用就不是正常调用，而是依次执行下面的步骤</p>
<ul>
<li>创建一个空对象，作为要返回的实例对象</li>
<li>将这空对象模型，指向构造函数的prototype属性</li>
<li>将空对象赋值给构造函数内部的this关键字。</li>
<li>开始执行构造函数内部的代码。</li>
</ul>
<p>也就是说，构造函数的内部，this指的是一个新生成的空对象，所有针对this的操作，都会发生在这个空对象上。构造函数之所以叫“构造函数”，也就是说这个函数的目的，就是操作一个空对象(this对象),将其“构造”为所需要的样子。<br>如果构造函数内有return语句，而且return后面跟着一个对象，new命令行将会返回return语句指定的对象，<br>否则不管return语句，返回this对象</p>
<p>但是如果return语句返回的是一个跟this无关的对象，new命令会返回这个新对象，而不是this对象。<br>如果普通函数(内部没有this关键字)使用new命令则会返回一个空对象.</p>
<p>new命令简化的内部流程，可以用下面的代码显示</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">_new</span>(<span class="params">constructor<span class="regexp">/*构造函数*/</span>,paraml<span class="regexp">/*构造函数的参数*/</span></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>);                <span class="comment">// 把arguments转成数组</span></div><div class="line">    <span class="keyword">var</span> <span class="keyword">constructor</span> = agrs.shift();                     // 取出构造函数</div><div class="line">    var context = Object.create(<span class="keyword">constructor</span>.prototype);</div><div class="line">    // 创建一个空对象，继承构造函数的prototype属性</div><div class="line">    var result = <span class="keyword">constructor</span>.apply(context,args);</div><div class="line">    //返回结果如果是对象，就直接返回，否则返回context对象</div><div class="line">    return (typeof result === "object" &amp;&amp; result != null)? result: context;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>3.3 new.target<br>函数内部可以使用new.target属性。如果当前函数是new命令调用的，new.target指向当前函数，否则指向undefined。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span>.target === fn);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(!<span class="keyword">new</span>.target)&#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'请使用new操作符调用！'</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.a = a;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</div><ul class="meta"><li><i class="icon icon-author"></i>zzjemery</li><li><i class="icon icon-clock"></i>11 Minutes</li><li><i class="icon icon-category"></i></li></ul></li><li> <p class="date">October 25, 2017</p><h4 class="title"><a href="/2017/10/25/hello-world/">Hello World</a></h4><div class="excerpt"></div><ul class="meta"><li><i class="icon icon-author"></i>zzjemery</li><li><i class="icon icon-clock"></i>2 Minutes</li><li><i class="icon icon-category"></i></li></ul></li></ul><ul class="pagination"><li class="current"><a>1</a></li></ul><div class="page-footer"><div class="top"><ul class="social"><li><a href="https://github.com/zzjemery" title="Github" target="_blank"><i class="icon icon-github"></i></a></li><li><a href="https://weibo.com/u/5296034647" title="Weibo" target="_blank"><i class="icon icon-weibo"></i></a></li><li><a href="https://www.segmentfault.com/u/bon" title="SegmentFault" target="_blank"><i class="icon icon-segmentfault"></i></a></li></ul></div><div class="bottom"><p class="copyright">© 2017 占志杰的博客<br><small>POWER BY <a href="https://hexo.io" target="_blank">HEXO</a></small><small>, THEME BY <a href="https://github.com/BoizZ/hexo-theme-laughing" target="_blank">LAUGHING</a></small></p></div></div></div><script>var wrap = document.getElementById('wrap');
window.onload = function () {
  wrap.className += ' done';
}</script></body></html>